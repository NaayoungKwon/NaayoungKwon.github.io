---
date: 2023-06-18
title: "25 클래스"
tags: [클래스, 상속, ]
categories:
  - Modern JavaScript
excerpt: 클래스,상속

permalink: /modern-javascript/25-클래스/

toc: true
toc_sticky: true
---


### 클래스는 프로토타입의 문법적 설탕인가?


> 새로운 객체 생성 메커니즘으로 보는 것이 좀 더 합당하다.

- 클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕이라고 볼 수도 있다.
- 단, 클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지는 않는다.
- 클래스는 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능을 제공한다.
	1. 클래스를 new 연산자 없이 호출하면 Error
	2. extends, super 지원
	3. 호이스팅이 동작하지 않는 것 처럼 동작한다.
	4. 클래스 내 모든 코드에는 암묵적으로 strict mode가 지정되어 실행된다.
	5. 클래스 내 모든 property attribute [[ Enumerable ]] 값이 false다.

### 클래스 정의
{% raw %}

```javascript
// 클래스 선언문
class Person {}

// 익명 클래스 표현식
const Person = class {};

// 기명 클래스 표현식
const Person = class MyClass {};
```
{% endraw %}


클래스를 표현식으로 정의할 수 있다는 것은 클래스가 값으로 사용할 수 있는 일급 객체라는 것을 의미한다.


![0](/assets/img/2023-06-18-25-클래스.md/0.png)


### 클래스 호이스팅
{% raw %}

```javascript
// 클래스 선언문
class Person {}

console.log(typeof Person); // function
```
{% endraw %}

- 클래스는 정의 이전에 참조할 수 없다.
- 클래스 선언문으로 정의한 클래스는 런타임 이전에 먼저 생성하여 평가한다.
- 클래스는 let, const 키워드로 선언한 변수처럼 호이스팅 되어, 일시적 사각지대에 빠지기 때문에 호이스팅이 발생하지 않는 것 처럼 보인다.

### 인스턴스 생성


클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다.


### 메서드

- 클래스 몸체에서 정의할 수 있는 메서드는 생성자, 프로토타입 메서드, 정적 메서드 3가지가 있다.
	- constructor
		- 인스턴스를 생성하고 초기화하기 위한 특수한 메서드
		- 매서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다.
		- 별도의 반환문을 갖지 않아야한다. new 연산자와 함께 클래스가 호출되면 생성자 함수와 동일하게 암묵적으로 this를 반환한다.
		- this가 아닌 다른 객체를 반환하면 return 문에 명시된 객체가 반환된다.
		- 명시적으로 원시값을 반환하면 원시값은 무시되고 this가 반환된다.
	- 프로토타입 메서드
		- 클래스 몸체에서 정의한 메서드는 생성자 함수에 의한 객체 생성 방식과는 다르게 클래스의 prototpye 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.
		- 클래스 몸체에 정의한 메서드는 인스턴스의 프로토타입에 존재하는 프로토타입 메서드가 된다.

			![1](/assets/img/2023-06-18-25-클래스.md/1.png)

	- 정적 메서드
		- 인스턴스를 생성하지 않아도 호출할 수 있는 메서드를 말한다.
		- 정적 메서드는 클래스에 바인딩된 메서드가 된다.

			![2](/assets/img/2023-06-18-25-클래스.md/2.png)

		- 정적 메서드는 인스턴스로 호출할 수 없다. 정적 메서드가 바인딩된 클래스는 인스턴스의 프로토타입 체인상에 존재하지 않기 때문
- 클래스에서 정의한 메서드의 특징
	- function 키워드를 생략한 메서드 축약 표현을 사용한다.
	- 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없다.
	- 암묵적으로 strict mode로 실행된다.
	- for...in 문이나 Object . keys 메서드 등으로 열거할 수 없다. 즉, 프로퍼티의 열거 가능 여부를 나타내며, 불리언 값을 갖는 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false다.
	- 내부 메서드 [[Construct]]를 갖지 않는 non-constructor다. 따라서 new 연산자와 함께 호출할 수 없다.

### 클래스의 인스턴스 생성 과정

1. 인스턴스 생성과 this 바인딩
2. 인스턴스 초기화
3. 인스턴스 반환

### 프로퍼티

- 인스턴스 프로퍼티
	- constructor 내부에서 정의해야한다.
	- 언제나 public 하다.
- 접근자 프로퍼티
	- set, get으로 접근자 함수로 구성된 프로퍼티
	- 인스턴스 프로퍼티가 아닌 프로토타입의 프로티가 된다.
- 클래스 필드
	- 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어다.
	- 아직 ECMAScript 정식 표준 사양으로 승급되지않았지만 최신 브라우저와 Node.js에서 구현해두었다.
	- 함수는 일급 객체이므로 함수를 클래스 필드에 할당할 수 있다. 따라서 클래스 필드를 통해 메서드를 정의할 수도 있다.
- private 필드
	- 접근자 프로퍼티를 통해 간접적으로 접근하는 방법은 유효하다.
- static 필드

## 상속에 의한 클래스 확장


### 클래스 상속과 생성자 함수 상속

- 상속에 의한 클래스 확장은 프로토타입 기반 상속과는 다른 개념이다.
	- 프로토타입 기반 상속 : 프로토타입 체인을 통해 다른 객체의 자산을 상속받는 개념
	- 상속에 의한 확장 : 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것
- 클래스는 extends 키워드가 제공된다.
- 생성자 함수는 클래스와 같이 상속을 통해 다른 생성자 함수를 확장할 수 있는 문법이 제공되지 않는다.

### extends 키워드

- 상속을 통해 확장된 클래스 : 서브 클래스, 파생 클래스, 자식 클래스
- 서브 클래스에게 상속된 클래스 : 수퍼 클래스, 베이스 클래스, 부모 클래스
- 수퍼 클래스와 서브 클래스는 인스턴스의 프로토타입 체인 뿐 아니라 클래스 간의 프로토타입 체인도 생성한다.

	![3](/assets/img/2023-06-18-25-클래스.md/3.png)


### 동적 상속

- extends 키워드 다음에는 클래스 뿐만 아니라 [[ Construct ]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다.
- 이를 통해 동적으로 상속받을 대상을 결정할 수 있다.
{% raw %}
```javascript
class Derived extends (condition ? Base1 : Base2) {}
```
{% endraw %}


### 서브 클래스의 constructor

- 클래스에서 constructor를 생략하면 클래스에 비어있는 constructor가 암묵적으로 정의된다.
{% raw %}
```javascript
constructor(...args) { super(...args); }
```
{% endraw %}


### super 키워드

- super를 호출하면 수퍼클래스의 constructor를 호출한다.
	- new 연산자와 함께 서브 클래스를 호출하면서 전달한 인수는 모두 서브클래스에 암묵적으로 정의된 constructor 의 super 호출을 통해 수퍼 클래스의 constructor에 전달된다.
{% raw %}
		```javascript
		// 수퍼클래스
		class Base { 
			constructor(a ,  b) { 
				this.a = a;
				this.b = b;
			} 
		}
		
		// 서브클래스
		class Derived extends Base {
			// 다음과 같이 암묵적으로 constructor가 정의된다.
			// constructor(...args) { super(...args); }
		}
		const derived = new Derived(1 ,  2);
		console.log(derived); // Derived {a: 1, b: 2}
		```
{% endraw %}

	- 수퍼 클래스에서 추가한 프로퍼티와 서브 클래스에서 추가한 프로퍼티를 갖는 인스턴스를 생성한다면 서브 클래스의 constructor를 생략할 수 없다.
- super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.
{% raw %}
	```javascript
	// 수퍼클래스
	class Base { 
		constructor(name) { 
			this.name = name;
		}
		sayHi() {
			return `Hi! ${this . name}`;
		} 
	}
	
	// 서브클래스
	class Derived extends Base { 
		sayHi() {
			// super.sayHi는 수퍼클래스의 프로토타입 메서드를 가리킨다.
			return `${super . sayHi()} . how are you doing?`;
		} 
	}
	const derived = new Derived('Lee');
	console.log(derived.sayHi()); // Hi! Lee. how are you doing?
	```
{% endraw %}


### 상속 클래스의 인스턴스 생성 과정

1. 서브 클래스의 super 호출
	- 수퍼/서브 클래스 구분을 위해 내부 슬롯 [[ ConstructorKind ]] 를 갖는다.
	- 다른 클래스를 상속받지 않으면 값을 ‘base’, 서브 클래스는 ‘derived’로 설정된다.
	- 이를 통해 수퍼 클래스와 서브 클래스는 new 연산자와 함께 호출되었을 때의 동작이 구분된다.
	- **서브 클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼 클래스에게 인스턴스 생성을 위임한다.**
2. 수퍼 클래스의 인스턴스 생성과 this 바인딩
	- 수퍼 클래스의 constructor 내부의 코드가 실행되기 이전에 암묵적으로 빈 객체를 생성한다.
	- 빈 객체, 즉 인스턴스는 this에 바인딩된다.
	- **인스턴스는 new.target이 가리키는 서브 클래스가 생성한 것으로 처리된다.**
{% raw %}
	```javascript
	// super class
	class Rectangle {
		constructor(width , height) {
			// 암묵적으로 빈 객체, 즉 인스턴스가 생성되고 this에 바인딩된다.
			console.log(this); // ColorRectangle {} // new 연산자와 함께 호출된 함수, 즉 new.target은 ColorRectangle이다.
			console.log(new.target); // ColorRectangle
			// 생성된 인스턴스의 프로토타입으로 ColorRectangle.prototype이 설정된다.
			console.log(Object.getPrototypeOf(this) === ColorRectangle.prototype); // true 
			console.log(this instanceof ColorRectangle); // true 
			console.log(this instanceof Rectangle); // true
	...
	```
{% endraw %}

3. 수퍼 클래스의 인스턴스 초기화
4. 서브 클래스 constructor로의 복귀와 this 바인딩
	- super가 반환한 인스턴스가 this에 바인딩 된다.
5. 서브 클래스의 인스턴스 초기화
6. 인스턴스 반환

### 표준 빌트인 생성자 함수 확장

- extends 키워드 다음에 클래스 뿐만 아니라 [[ Construct ]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다.
- ex. Array 생성자 함수를 상속받아 확장한 MyArray 클래스가 생성한 인스턴스는 Array.prototype과 MyArray.prototype의 모든 메서드를 사용할 수 있다.
