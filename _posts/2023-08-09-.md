---
date: 2023-08-09
title: ""
tags: [커버리지 지표, ]
categories:
  - unit-test
excerpt: 커버리지 지표

permalink: /unit-test//

toc: true
toc_sticky: true
---


## 단위 테스트의 목표

- 단위 테스트의 목표는 소프트웨어 프로젝트의 **지속 가능한 성장**을 가능하게 하는 것
- 소프트웨어 엔트로피 : 시간이 지나면서 더 많은 시간을 들여야 처음에 보여준 것과 같은 프로젝트 성장속도를 낼 수 있다는 현상
- 소프트웨어 엔트로피는 개발 속도 뿐만 아니라 코드 품질을 떨어트리는 형태로 나타난다.
	- 지속적인 정리와 refactoring과 같은 적절한 관리 없이 방치하면 시스템이 더 무질서해진다.
	- 버그를 수정할 수록 더 많은 버그를 양산하고, 한 부분을 수정하면 다른 부분이 고장난다.

	→ 코드를 신뢰할 수 없게된다.

- 테스트는 새로운 기능을 도입하거나 refactoring 후에도 기존 기능이 잘 작동 하는지 확인하는데 도움이 된다.
- 테스트는 초반에는 노력이 필요하지만, 지속성과 확장성을 통해 장기적으로 개발 속도를 유지할 수 있다.

### 좋은 테스트와 좋지 않은 테스트를 가르는 요인

- 모든 테스트를 작성할 필요는 없다.
- 기반 코드를 refactoring 할 때 Test도 refactoring 하라.
- Test가 잘못된 경고를 발생시킬 경우 처리하라.
- 기반 코드가 어떻게 동작하는지 이해하려고 할 때는 테스트를 읽는 데 시간을 투자하라.

![0](/assets/img/2023-08-09-.md/0.png)


## 테스트 스위트 품질 측정을 위한 커버리지 지표

- 커버리지 지표는 중요한 피드백을 주더라도 테스트 스위트 품질을 효과적으로 측정하는데 사용될 수 없다.
- **coverage가 너무 낮으면 테스트가 충분하지 않다는 증거이긴 하나, 100% coverage가 반드시 양질의 테스트 스위트를 보장하지 않는다.**

### 코드 커버리지 지표에 대한 이해


$$
코드 커버리지 = \frac{제품 코드 라인 수}{전체 라인 수}
$$


아래 두 개의 예제가 똑같은 표현이나 코드 커버리지 상으로는 차이가 있기 때문에, 코드 커버리지 숫자가 절대 지표가 될 수 없다는 것을 보여준다.
{% raw %}

```java
public static boolean IsStringLong(String input)
{
	if(input.length() > 5)
		return true;
	return false;
}
```
{% endraw %}
{% raw %}

```java
public static boolean IsStringLong(String input){
	return input.length() > 5;
}
```
{% endraw %}


### 분기 커버리지 지표에 대한 이해


$$
분기 커버리지 = \frac{통과 분기}{전체 분기 수}
$$

- 원시 코드 라인 수를 사용하는 대신 if 문과 switch 문과 같은 **제어 구조에 중점을 둔다**.
- 예제 1.2의 분가는 2개로, 문자열의 길이가 5를 초과하거나 그렇지 않은 경우다.
- 분기 개수만 다루기 때문에, 해당 분기를 구현하는데 얼마나 코드가 필요한지 고려하지 않는다.

### 커버리지 지표에 관한 문제점


테스트 스위트의 품질을 결정하는데 어떤 커버리지 지표도 의존할 수 없는 이유는 다음과 같다.

- 모든 가능한 결과를 검증한다고 보장할 수 없다.
	- 아래 코드에서 Test1은 `wasLastStringLong` 에 대한 검증을 하지 않았기 때문에 모든 지표를 측정하지 않았다.
	- Test2는 커버리지 지표와 분기 커버리지가 둘 다 100%를 나타내지만 검증이 없는 테스트이다.
{% raw %}
	```java
	public class UnitTest{
	
		public boolean wasLastStringLong;
	
		public boolean IsStringLong(String input){
		    boolean result = input.length() > 5;
		    wasLastStringLong = result;
		    return result;
		}
		
		public void Test1(){
		    boolean result = IsStringLong("abc");
		    Assert.Equal(result, false);
		}
	
		public void Test2(){
		    boolean result = IsStringLong("abc");
		    boolean result2 = IsStringLong("abcdef");
		}
	}
	```
{% endraw %}

- 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.
	- `Integer.parseInt(input)` 의 내부에서 input이 null, String, “” 등에 따라 많은 예외 상황에 빠질 수 있지만, 테스트에서 모든 예외를 다루는지 확인할 수 없다.

> 📌 코드 커버리지를 측정하는 것은 품질 테스트 스위트로 가는 첫걸음일 뿐이다.


## 무엇이 성공적인 테스트 스위트를 만드는가?


테스트 스위트가 얼마나 좋은지 자동으로 확인할 수 없으며, 개인 판단에 맡겨야 한다.


성공적인 테스트 스위트는 다음과 같은 특성을 갖고 있다.

1. 개발 주기에 통합돼 있다.
	- 자동화된 테스트를 할 수 있는 방법은 끊임없이 하는 것 뿐이다.
2. 코드베이스에서 가장 중요한 부분만을 대상으로 한다.
	- 시스템의 가장 중요한 부분에 단위 테스트 노력을 기울이고, 다른 부분은 간략하게 또는 간접적으로 검증하는 것이 좋다.
	- 비지니스 로직 테스트가 시간 투자 대비 최고의 수익을 낼 수 있다.
3. 최소한의 유지비로 최대의 가치를 끌어낸다.
	- 테스트를 빌드 시스템에 통합하는 것 만으로는 충분하지 않으며, 도메인 모델에 높은 테스트 커버리지를 유지하는 것도 충분하지 않다.
	- 가치있는 테스트를 식별하고 작성할줄 알아야 한다.

---


### 스터디 진행하면서 알게된 것


[bookmark](https://www.youtube.com/watch?v=jdlBu2vFv58)

- 빌드 시 커버리지 100%가 되지 않으면 빌드가 실패하도록 강제했다
- 장점
	- 테스트 작성에는 시간과 노력이 많이 들지만, 커버리지가 높을수록 배포에 대한 두려움이 사라짐
	- 코드 가독성 개선과 대규모 리팩토링 가능해졌다
	- 이미 작성한 테스트 코드를 참고하다보니 테스트 코드 작성이 점점 쉬워졌다
- 어려웠던 점
	- 테스트 속도 문제 해결을 위해 성능 프로파일링 및 개선 작업 실시
	- 어려운 테스트 케이스에 대한 대응책은 다양하게 존재하지만, 커버리지 검사 도구의 파일 제외 기능 활용 권장
	- 그럼에도 불구하고 테스트를 잘못 작성하거나 요구 사항의 오해로 버그는 여전히 나올 수 있다

정적 분석 도구 sonarqube

