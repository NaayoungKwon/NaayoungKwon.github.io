---
date: 2023-09-20
title: "7장. 가치있는 단위 테스트를 위한 리팩터링"
tags: [리팩토링, Humble Object, CanExecute, 도메인 이벤트, 코드의 유형, ]
categories:
  - unit-test

permalink: /unit-test/7장.-가치있는-단위-테스트를-위한-리팩터링/

toc: true
toc_sticky: true
---


## 리팩터링 할 코드 식별하기

- 모든 제품 코드는 2차원으로 분류할 수 있다.
	- `복잡도 또는 도메인 유의성` : 코드 내 분기 지점 수 / 코드가 프로젝트의 문제 도메인에 **얼마나 의미**있는지
	- `협력자 수` : 가변 의존성, 프로세스 외부 의존성

### 코드의 네가지 유형


![0](/assets/img/2023-09-20-7장.-가치있는-단위-테스트를-위한-리팩터링.md/0.png)

- **도메인 모델과 알고리즘**
	- 단위 테스트가 노력 대비 가장 이롭다.
	- 테스트의 회귀 방지가 향상되기 때문에 가치있다.
	- 코드에 협력자가 거의 없어 테스트 유지 비용이 저렴하다.
- 간단한 코드
	- 테스트 가치가 0에 가깝다.
	- 포괄적인 통합 테스트의 일부로서 간단히 테스트해야 한다.
- 컨트롤러
	- 비지니스에 중요한 작업이 아닌 도메인 클래스와 외부 애플리케이션 같은 다른 구성 요소의 작업을 조정한다.
- **지나치게 복잡한 코드**
	- 단위 테스트가 가장 어렵다.
	- 이를 도메인 모델 및 알고리즘과 컨트롤러라는 두 부분으로 나누는 것이 일반적이다.

> 도메인 모델과 알고리즘만 단위테스트 하는 것이 매우 가치있고 유지 보수가 쉬운 테스트 스위트로 가는 길이다.  
> 목표를 테스트 커버리지 보다는 각각의 테스트가 프로젝트 가치를 높이는 테스트 스위트인지 생각해보자.


### Humble Object Pattern

- `험블 객체 패턴`
	- 테스트가 어려운 행위들을 <u>단위테스트가 쉬운 행위</u>, <u>테스트가 어려운 행위</u> 두가지 모듈 또는 클래스로 나누는 것
	- 테스트가 어려운 모듈이 험블 객체 부분이다.

![1](/assets/img/2023-09-20-7장.-가치있는-단위-테스트를-위한-리팩터링.md/1.png)_어려운 의존성과 결합된 코드는 테스트하기 어렵다._


![2](/assets/img/2023-09-20-7장.-가치있는-단위-테스트를-위한-리팩터링.md/2.png)_어려운 의존성과 결합된 코드는 테스트하기 어렵다._


![3](/assets/img/2023-09-20-7장.-가치있는-단위-테스트를-위한-리팩터링.md/3.png)_험블 객체 패턴은 지나치게 복잡한 코드에서 로직을 추출해 코드를 테스트할 필요가 없도록 간단하게 만든다._

- 육각형 아키택처와 함수형 아키택처 모두 이 패턴을 구현한다.
	- 육각형 아키택처 : 비지니스 로직과 프로세스 외부 의존성과의 통신을 분리
	- 함수형 아키택처 : 프로세스 외부 의존성뿐만 아니라 모든 협력자와의 커뮤니케이션에서 비지니스 로직을 분리한다. 함수형 코어에는 아무런 협력자가 없다.
- 비지니스 로직과 **오케스트레이션**을 분리하는 경우
	- 오케스트레이션 : 코드의 너비가 넓은걸 말하는건지? → 다 개선되면 컨트롤러가 되지 않을까
- MVP, MVC, DDD, 집계 패턴도 이 예시다.
	- 집계 패턴 : 클래스를 클러스터로 묶어서 클래스 간 연결을 줄이는 것. 클래스는 클러스터 내부에 강결합돼 있지만, 클러스터 자체는 느슨하게 결합되어 코드 베이스의 총 통신 수를 줄인다.

## 가치 있는 단위 테스트를 위한 리팩터링


### 험블 객체 패턴을 사용한 리팩터링

1. 암시적 의존성을 명시적으로 만들기
	- DB와 메시지 버스는 테스트에서 목으로 처리한다.
	- 도메인 모델은 직/간접적으로 프로세스 외부 협력자에게 의존하지 않는 것이 훨씬 더 깔끔하다.
2. 애플리케이션 서비스 계층을 도입
	- 외부 시스템과 직접 통신하는 문제는 험블 컨트롤러로 책임을 옮긴다.
3. 애플리케이션 서비스 복잡도 낮추기
	- ORM이나 팩토리 클래스를 통해 재구성 로직을 추출한다.
4. 새 클래스 생성
	- 맞지 않는 로직은 새로운 클래스의 인스턴스가 처리하도록 위임한다.

### 최적의 단위 테스트 커버리지 분석

- 험블 객체 패턴을 사용해 리팩토링을 하고난 후, 맨 처음 봤던 코드의 4가지 유형 중 각 코드들이 어디에 속하는지 분석해 본다.
- 도메인 계층과 유틸리티 코드 테스트 : 비용 편익 측면에서 최상의 결과
- 나머지 세 사분면 : 복잡도가 높고 협력자가 많은 코드를 리팩터링으로 제거하여 테스트할 것이 없다.
- 전제 조건을 테스트해야할까? : 도메인 유의성이 없는 전제 조건을 테스트하는 데 시간을 들이지 말라.

## 컨트롤러에서 조건부 로직 처리

- 의사결정 프로세스 중간 결과를 기반으로 외부 의존성에 추가 조회를 하는 경우 분리가 어렵다.
- 3가지 방법

	![4](/assets/img/2023-09-20-7장.-가치있는-단위-테스트를-위한-리팩터링.md/4.png)

	- 외부에 대한 모든 읽기와 쓰기를 가장자리로 밀어낸다.
		- 성능 저하
		- 필요 없는 경우에도 컨트롤러가 프로세스 외부 의존성을 호출
	- 도메인 모델에 프로세스 외부 의존성을 주입하고 비지니스 로직이 해당 의존성을 호출할 시점을 직접 결정
		- 도메인 모델의 테스트 유의성이 떨어진다.
	- **의사 결정 프로세스 단계를 더 세분화**하고, 각 단계별로 컨트롤러 실행
		- 컨트롤러가 단순하지 않다.

### CanExecute/Execute Pattern

- `CanExecute`
	- 명령이 현재 실행 가능한지 확인하는 역할.
	- 현재 상태에서 명령을 실행할 수 있는지 여부를 판단하는 로직을 포함.
	- 불리언 값을 반환
- `Execute`
	- 실제로 명령을 실행하는 역할.
	- "실행(Execute)" 버튼이나 메뉴 아이템을 클릭했을 때 호출되며, 그에 따라 해당 명령이 수행

### 도메인 이벤트를 사용해 도메인 모델 변경사항 추적

- 도메인 이벤트 : 도메인 전문가에게 중요한 이벤트

## 결론

- 도메인 이벤트와 CanExecute/Execute Pattern을 사용해 도메인 모델에 모든 의사 결정을 담을 수 있지만 항상 그렇게 할 수는 없다.
- 협력자와의 상호작용을 검증하려고 목을 사용하지 말라
- 식별할  수 있는 동작과 구현 세부 사항을 양파의 여러 겹으로 생각하여, 해당 계층이 기저 계층과 어떻게 통신하는지는 무시하라.
