---
layout: post
date: 2023-10-18
title: "10장. 데이터베이스 테스트"
tags: [DB, Transaction, ORM, Migration, ]
categories:
  - unit-test

permalink: /unit-test/10장.-데이터베이스-테스트/

toc: true
toc_sticky: true
---


## 데이터베이스 테스트를 위한 전제 조건

- 통합 테스트에서는 관리 의존성이 그대로 있어야 한다.
- 목을 사용하는 것은 불가능하기 때문에 비관리 의존성보다 작업하기가 더 힘들 수 있다.
- 테스트를 작성하기 전에는 통합 테스트가 가능하게 끔 준비 단계를 수행해야한다.
	- 형상 관리 시스템에 데이터베이스 유지
	- 모든 개발자를 위한 별도의 데이터베이스 인스턴스 사용
	- 데이터베이스 배포에 마이그레이션 기반 방식 적용

### 형상 관리 시스템에 데이터베이스 유지

- DB Test의 첫 번째 단계 : 데이터베이스 스키마를 일반 코드로 취급하자.
- 모델 데이터베이스를 사용하는 것은 데이터베이스 스키마를 유지하는 데 상당히 좋지 못한 방법이다.
	- No change history : DB Schema를 과거의 특정 시점으로 되돌릴 수 없다.
	- No single source of truth : The model database becomes a competing source of truth about the state of development. 이렇게 기준을 두 가지(Git + 모델 데이터베이스)로 두면 부담이 가중된다.

	![0](/assets/img/2023-10-18-10장.-데이터베이스-테스트.md/0.png)

- **모든 데이터베이스 스키마 업데이트를 형상 관리 시스템에 두면 원천 정보를 하나로 할 수 있고, 일반 코드 변경과 함께 데이터베이스 변경을 추적할 수 있다.**

### 참조 데이터도 데이터베이스 스키마

- 데이터베이스 스키마에 관해 테이블, 뷰, 인덱스, 저장 프로시저 등 데이터베이스 구성 방식의 청사진을 구성하는 모든 것이다.
- 스키마는 SQL 스크립트 형태로 표현된다.
- DB 스키마로 여기지 않는 부분은 참조 데이터다.

> 참조 데이터 : Application이 제대로 동작하도록 미리 채워야하는 데이터

- 수정할 수 있는 데이터와 수정할 수 없는 데이터(참조 데이터)를 구분하는 플래그를 두고, 애플리케이션이 참조 데이터를 변경하지 못하게 해야한다.
- **참조 데이터는 애플리케이션의 필수 사항이므로, 테이블, 뷰 그리고 다른 데이터베이스 스키마와 함께 SQL INSERT문 형태로 형상 관리 시스템에 저장해야한다.**

### 모든 개발자를 위한 별도의 데이터베이스 인스턴스

- 실제 데이터베이스로 테스트하는 것은 어렵고, 다른 개발자들과 데이터베이스를 공유해야한다면 훨씬 더 어려워진다.
- 테스트 실행 속도를 극대화하려면 개발자마다 별도로 데이터베이스 인스턴스를 사용하라

### 상태 기반/ 마이그레이션 기반 데이터베이스 배포

- 상태 기반 방식
	- 앞에서 설명한 모델 데이터베이스 방식과 유사하다.
	- 배포 중에 비교 도구가 스크립트를 생성해서 운영 데이터베이스를 모델 데이터베이스와 비교해 최신 상태로 유지한다.
	- 스크립트는 형상 관리에 저장된다.
	- 비교 도구는 불필요한 테이블을 삭제하고 새 테이블을 생성하고 컬럼명을 바꾸는 등 모델 데이터베이스와 동기화하는 데 필요한 모든 작업을 수행한다.
- 마이그레이션 방식
	- 다른 버전으로 전환하는 명시적인 마이그레이션을 의미한다.
	- 이 방식은 업그레이드 스크립트를 직접 작성해야한다.
	- 하지만 운영 데이터베이스 스키마에서 문서화되지 않은 변경 사항을 발견할 때 데이터베이스 비교 도구가 아직 유용할 수 있다.

	![1](/assets/img/2023-10-18-10장.-데이터베이스-테스트.md/1.png)

- **마이그레이션 방식이 초기 구현과 유지보수가 어렵지만 장기적으론 상태 기반 방식보다 훨씬 효과적이다.**
	- 데이터베이스 상태가 병확하면 병합 충돌을 처리하기가 수월한 반면, 명시적 마이그레이션은 데이터 모션 문제를 해결하는데 도움이 된다.
	- 대부분의 프로젝트에서는 데이터 모션이 병합 충돌보다 훨씬 중요하다.

	> 데이터 모션 : 새로운 데이터베이스 스키마를 준수하도록 기존 데이터의 형태를 변경하는 과정


	![2](/assets/img/2023-10-18-10장.-데이터베이스-테스트.md/2.png)


## 데이터베이스 트랜잭션 관리


### 제품 코드에서 트랜잭션 관리하기

- 책의 예시 CRM 프로젝트에서는 DB가 각 메서드 호출에서 별도의 SQL 연결을 생성하고 암묵적으로 트랜잭션을 독립적으로 처리한다.
- 읽기 전용 연산 중에는 여러 트랜잭션을 열어도 괜찮다.
- 비지니스 연산에 데이터 변경이 포함된다면, 모순을 피하고자 이 연산에 포함된 모든 업데이터는 Atomic 해야한다.

**[ 데이터베이스 트랜잭션에서 데이터베이스 연결 분리하기 ]**

- 잠재적 모순을 피하려면 결정 유형을 두 가지로 나눠야한다.
	- 업데이터 할 데이터
	- 업데이트 유지 또는 롤백 여부
- DB 클래스를 Repository와 트랜잭션으로 나눠서 이런 책임을 구분할 수 있다.
	- Repository : DB의 데이터에 대한 접근과 수정을 가능하게 하는 클래스
	- Transaction : 데이터 업데이트를 완전히 커밋하거나 롤백하는 클래스. 원자성 확보
		- Commit() : 트랜젝션을 성공으로 표시. 컨트롤러가 호출한다.
		- Dispose() : 트랜잭션을 종료한다. 이전에 Commit이 호출된 경우 Dispose는 모든 데이터 업데이트를 저장하고, 그렇지 않으면 롤백한다.
- 트랜잭션이 컨트롤러와 데이터베이스 간의 상호 작용을 조정해서 Atomic하게 데이터를 수정할 수 있다.

![3](/assets/img/2023-10-18-10장.-데이터베이스-테스트.md/3.png)


**[ 작업 단위로 트랜잭션 업그레이드하기 ]**

- Transaction 클래스르 작업 단위로 업그레이드 할 수 있다.

> 작업 단위 : 비지니스 연산에 영향을 받는 객체 목록이 있다. 작업이 완료되면, 작업 단위는 DB를 변경하기 위해 해야하는 업데이트를 모두 파악하고 이런 업데이트를 하나의 단위로 실행한다.

- 일반 트랜잭션과 비교해서 작업 단위가 갖는 큰 장점은 업데이트 지연이다.
- 트랜잭션의 기간을 단축하고 데이터 혼잡을 줄인다.

![4](/assets/img/2023-10-18-10장.-데이터베이스-테스트.md/4.png)

- 대부분의 ORM 라이브러리가 작업 단위 패턴을 구현한다.

### 통합 테스트에서 데이터베이스 트랜잭션 관리하기

- 테스트 구절 간에 데이터베이스 트랜잭션이나 작업 단위를 재사용하지 말라.
- 실행 구절에서 CrmContext를 다른 것과 공유하면 안 된다.
- 입력 매개변수로 사용되는 데이터와는 별개로 데이터베이스 상태를 확인하는 것이 중요하기 때문에 준비 구절과 검증 구절에서 CrmContext 인스턴스를 가져와야한다.

## 테스트 데이터 생명 주기

- 공유 데이터 베이스를 사용하면 통합 테스트를 서로 분리할 수 없는 문제가 생긴다.
- 위의 문제를 해결하기 위해서
	- 통합 테스트를 순차적으로 실행하라.
	- 테스트 실행 간에 남은 데이터를 제거하라.
- 테스트는 데이터베이스 상태에 따라 달라지면 안되며, 테스트는 데이터베이스 상태를 원하는 조건으로 만들어야한다.

### 병렬 테스트 실행과 순차적 테스트 실행

- 성능 향상을 위해 시간을 허비하지 말고 순차적으로 통합 테스트를 실행하는 것이 더 실용적이다.
- 대안으로 컨테이너를 사용해 테스트를 병렬 처리할 수도 있다.
	- 유지 보수 부담이 너무 커지게된다.

### 테스트 실행 간 데이터 정리

- 데이터를 정리하는 4가지 방법
	- 각 테스트 전에 데이터베이스 백업 복원하기
		- 데이터 정리 문제를 해결할 수 있지만 느리다.
	- 테스트 종료 시점에 데이터 정리하기
		- 빠르지만 정리 단계를 건너뛰기 쉽다.
	- 데이터베이스 트랜잭션에 각 테스트를 래핑하고 커밋하지 않기
		- 변경한 모든 내용을 자동으로 롤백한다.
		- 추가 트랜잭션으로 인해 운영 환경과 다른 설정이 생성될 수 있다.
	- 테스트 시작 시점에 테이터 정리하기
		- 가장 좋다.
		- 빠르게 작동하고 일관성 없는 동작을 일으키지 않으며, 정리 단계를 실수로 건너뛰지 않는다.
- 외래 키 제약 조건을 준수하려면 특정 순서에 따라 데이터를 제거해야한다.
	- SQL 스크립트를 수동으로 작성하면 더 간단하고 삭제 프로세스를 세밀하게 제어할 수 있다.

### 인메모리 데이터베이스 피하기

- 인메모리 데이터베이스로 교체 했을 때 장점
	- 테스트 데이터를 제거할 필요가 없음
	- 작업 속도 향상
	- 테스트가 실행될 때 마다 인스턴스화 가능
- 인메모리 데이터베이스는 일반 데이터베이스와 기능적으로 일관성이 없기 때문에 사용하지 않는 것이 좋다.
- 차이로 인해 거짓 양성 또는 거짓 음성이 발생하기 쉽다.

## 테스트 구절에서 코드 재사용하기

- 통합 테스트는 가능한 짧게 하되 서로 결합하거나 가독성에 영향을 주지 ㅇ낳는 것이 중요하다.
- 서로 의존해서는 안 된다.
- 통합 테스트를 짧게 하기 위해 가장 좋은 방법은 비지니스와 관련이 없는 기술적인 부분을 비공개 메서드나 헬퍼 클래스로 추출하는 것이다.

### 준비/실행/검증 구절에서 코드 재사용

- 준비 구절에서 코드 재사용하기
	- 비공개 팩토리 메서드를 도입하라
	- 기본값을 사용하면 인수를 선택적으로 지정해 테스트를 단축할 수 있다.
- 실행 구절에서 코드 재사용하기
	- 어떤 컨트롤러 기능을 호출해야 하는지에 대한 정보가 있는 대리자를 받는 메서드를 도입할 수 있다.
- 검증 구절에서 코드 재사용하기
	- CreateUer나 CreateCompany와 유사한 엘퍼 메서드를 두는 것이다.
	- 데이터 검증을 위한 플루언트 인터페이스를 만들 수 있다.

### 테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가?

- 어느정도 문제가 되기는 하지만, 할 수 있는 것은 많지 않다.
- 빠른 피드백과 유지 보수성 간의 절충이 필요하다
- **성능 저하가 그다지 크지 않고, 유지 보수성 측면에서도 상당한 이점이 있다.**

## 데이터베이스 테스트에 대한 일반적인 질문


### 🧐 읽기 테스트를 해야하는가?

- 위험성이 높은 쓰기는 철저히 테스트하는 것이 중요하다.
- 하지만 읽기는 이에 해당하지 않는다.
- **읽기 테스트 임계치는 쓰기 테스트 임계치 보다 높아야 한다.**
- 가장 복잡하거나 중요한 읽기 작업만 테스트하고, 나머지는 무시하라.
- 테이터 변경이 없으면 읽기 캡슐화는 의미가 없다.
- **읽기를 테스트하기로 결정한 경우에는 실제 테이터베이스에서 통합 테스트를 하라**

![5](/assets/img/2023-10-18-10장.-데이터베이스-테스트.md/5.png)


### 🧐 리포지터리 테스트를 해야하는가?

- 리포지터리를 다른 통합테스트와 독립적으로 테스트 하기에는 유지비가 높고 회귀 방지가 떨어져서 테스트 스위트에 손상이 된다.
- 단점
	- 높은 유지비
		- 컨트롤러 사분면에 포함된다.
		- 복잡도가 거의 없고 프로세스 외부 의존성인 데이터베이스와 통신한다.

		![6](/assets/img/2023-10-18-10장.-데이터베이스-테스트.md/6.png)

	- 낮은 회귀 방지
		- 회귀 방지에서 일반적인 통합 테스트가 주는 이점과 겹친다. → 레포지터리 테스트는 가치를 더 주지 못한다.
		- 약간의 복잡도가 있다면 별도의 알고리즘으로 추출하고 해당 알고리즘 전용 테스트를 작성하라.
		- ORM을 사용할 때 데이터 매핑과 데이터베이스 상호작용 간의 분리는 불가능하다.
- **리포지토리는 직접 테스트하지 말고, 포관ㄹ적인 통합 테스트 스위트의 일부로 취급하라.**

[https://medium.com/daangn/효율적인-테스트를-위한-stub-객체-활용법-5c52a447dfb7](https://medium.com/daangn/%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-stub-%EA%B0%9D%EC%B2%B4-%ED%99%9C%EC%9A%A9%EB%B2%95-5c52a447dfb7)

