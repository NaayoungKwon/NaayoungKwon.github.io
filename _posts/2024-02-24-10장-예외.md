---
date: 2024-02-24
title: "10장 예외"
tags: [exception, error, RuntimeExeption, ]
categories:
  - Effective Java
excerpt: exception,error,RuntimeExeption

permalink: /effective-java/10장-예외/

toc: true
toc_sticky: true
---


## Error, Checked Exception, Unchecked Exception


![0](/assets/img/2024-02-24-10장-예외.md/0.png)


[bookmark](https://devlog-wjdrbs96.tistory.com/351)


## 69. 예외는 진짜 예외 상황에서만 사용하라

- 예외를 사용하면 표준 관용구 보다 훨씬 느리다.
- 예외는 오직 예외 상황에서만 써야한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안된다.
- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.
- 특정 상태에서만 호출할 수 있는 만큼 상태 의존적 메서드는 제공하는 크래스는 상태 검사 메서드도 함께 제공해야한다.
	- 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침
		- 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 Optional이나 특정 갑을 사용한다.
		- 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 수행한다면 옵셔널이나 특정 값을 선택한다.
		- 다른 모든 경우엔 상태 검사 메서드 방식이 좀 더 낫다

## 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라


자바가 문제 상황을 알리는 타입 : 검사 예외, 런타임 예외, 에러


### 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라

- 검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다.
- 비검사 throwable은 두 가지로, 런타임 예외와 에러다
	- 둘 다 동작 측면에서는 다르지 않다
	- 통상적으로는 프로그램에서 잡지 말아야한다
	- 복구 불가능하거나 더 실행해봐야 득보다는 실이 많다.
- **프로그래밍 오류를 나타낼 때는 런타임 예외**를 사용하자
	- 런타임 예외는 전제 조건을 만족하지 못했을 때 발생한다.
- 에러는 보통 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행할 수 없는 상황을 나타낼 때 사용한다.
- 우리가 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.
- 오류 메시지를 파싱해 정보를 빼내는 것은 나쁜 습관이다.
	- 코드가 깨지기 쉽고 다른 환경에서 동작하지 않을 수 있다.
- **검사 예외는 복구할 수 있는 조건**일 때 발생한다.

## 71. 필요 없는 검사 예외 사용은 피하라

- 검사 예외를 과하게 사용하면 오히려 쓰기 불편한 API가 된다.
	- 어떤 메서드가 검사 예외를 던질 수 있다고 선언 됐다면, 이를 호출하는 코드에서는 catch 블록을 두어 그 예외를 붙잡아 처리하거나 더 바깥으로 던져 문제를 전파 해야만 한다.
- API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머나 의미 있는 조치를 취할 수 있는 경우가 둘 다 아니라면 비검사 예외를 사용하는게 좋다.
- 검사 예외를 회피하는 방법은 적절한 결과 타입을 담음 옵셔널을 반환하는 것이다.
	- 단점 : 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다.
	- 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다.

## 72. 표준 예외를 사용하라

- Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자
	- 추상 클래스라고 생각해라

### 표준 예외를 재사용

- IllegalArgumentException
	- 호출자가 인수로 부적절한 값을 넘길 때 던짐
- IllegalStateException
	- 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때
- NullPointerException
	- null을 허용하지 않는 메서드에서 null을 건냈을 때
- ConcurrentModificationException
	- 단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때
- UnsupportedOperationException
	- 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때

## 73. 추상화 수준에 맞는 예외를 던져라

- 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 던져야한다.
- 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄를 사용하는게 좋다.
	- 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식
{% raw %}
		```java
		try{
		// 저수준의 추상화
		} catch (LowerLevelException cause) {
			throw new HigherLevelException(cause);
		}
		```
{% endraw %}

	- 무턱대고 예외를 전파하는 것 보다야 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 곤란하다
- 아래 계층에서 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리하여 문제를 API 호출자에까지 전파하지 않는 방법이 있다.

## 74. 메서드가 던지는 모든 예외를 문서화하라

- 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바 독의 @throws 태그를 사용하여 정확히 문서화하자
- 비검사 예외는 매서드 선언의 throws 목록에 넣지 말자

## 75. 예외의 상세 메시지에 실패 관련 정보를 담으라

- 자바 시스템은 예외의 스택 추적 정보를 자동으로 출력한다.
- 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개 변수와 필드의 값을 실패 메시지에 담아야 한다.
- 예외의 상세 메시지와 최종 사용자에게 보여줄 오류 메시지를 혼동해서는 안된다.
	- 최종 사용자에게는 친절한 안내 메시지를 보여줘야한다
	- 예외 메시지는 가독성 보다는 담긴 내용이 중요하다

## 76. 가능한 한 실패 원자적으로 만들라

- 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다.
	- → 실패 원자적 (failure-atomic)

### 메서드를 실패 원자적으로 만드는 방법

- 불변 객체로 설계
	- 불변 객체의 상태는 생성 시점에 고정되어 절대 변하지 않는다.
	- 메서드가 실패하면 새로운 객체가 만들어지지는 않을 수 있으나 기존 객체가 불안정한 상태에 빠지는 일은 결코 없다.
- 실패할 가능성이 있는 모든 코드를, 객체 상태를 바꾸는 코드보다 앞에 배치
	- 예시. TreeMap에 원소를 추가하려면 트리 변경에 앞서 해당 원소가 비교할 수 있는 타입인지 확인
- 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체
- 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌린다.
- 실패 원자성은 일반적으로 권장되는 덕목이지만 항상 달성할수 있는 것은 아니다.

## 77. 예외를 무시하지 말라

- 메서드 선언에 예외를 명시하는 이유는 그 메서드를 사용할 때 적절한 조치를 취해달라고 말하는 것
- catch 블록을 비워두면 예외가 존재할 이유가 없어진다.
- 예외를 무시하기로 했다면 catch 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 ignored로 바꿔놓자
- 무시하지 않고 바깥으로 전파되게만 놔둬도 최소한 디버깅 정보를 남긴 채 프로그램이 신속히 중단되게는 할 수 있다.
