---
date: 2023-10-04
title: "8장 통합 테스트를 하는 이유"
tags: [통합테스트, 외부 의존성, 관리 의존성, 비관리 의존성, 로깅, ]
categories:
  - Unit Test
excerpt: 통합테스트,외부 의존성,관리 의존성,비관리 의존성,로깅

permalink: /unit-test/8장-통합-테스트를-하는-이유/

toc: true
toc_sticky: true
---


> 💡 식별할 수 있는 동작인지, 구현 세부 사항인지 여부에 대한 관점으로 프로세스 외부 의존성과의 통신을 살펴보자


## 통합 테스트는 무엇인가?


### 통합 테스트의 역할

- 단위 테스트가 아닌 모든 테스트가 통합 테스트에 해당한다.
- 컨트롤러 사분면에 속하는 코드를 다룬다.

	![0](/assets/img/2023-10-04-8장-통합-테스트를-하는-이유.md/0.png)

- 프로세스 외부 의존성과 도메인 모델을 연결하는 코드를 확인한다.

### 테스트 피라미드

- 단위 테스트와 통합 테스트 간의 균형을 유지하는 것이 중요하다.
- 통합 테스트는 프로세스 외부 의존성에 직접 작동하면 느려지며, 유지비가 많이 든다.
- 하지만 회귀 방지가 우수하며, 리팩터링 내성도 우수하다.
- **단위 테스트로 가능한 한 많이 비지니스 시나리오의 예외 상황을 확인하고, 통합 테스트는 주요 흐름과 단위 테스트가 다루지 못하는 기타 예외 사항을 다룬다.**
	- 주요 흐름 : 시나리오의 성공적인 실행
	- 예외 상황 : 비지니스 시나리오 수행 중 오류가 발생하는 경우
- 테스트 피라미드는 프로젝트의 복잡도에 따라 모양이 다를 수 있다.

	![1](/assets/img/2023-10-04-8장-통합-테스트를-하는-이유.md/1.png)

- 통합 테스트는 단순한 애플리케이션에서도 가치가 있다. 코드가 얼마나 간단한지 보다 다른 서브 시스템과 통합해 어떻게 작동하는지 확인하는 것이 더 중요하다.

![2](/assets/img/2023-10-04-8장-통합-테스트를-하는-이유.md/2.png)


### 통합 테스트와 빠른 실패

- 통합 테스트에서 프로세스 외부 의존성과의 상호 작용을 모두 확인하려면 가장 긴 주요 흐름을 선택하라.
- 모든 상호작용을 거치는 흐름이 없으면, 외부 시스템과의 통신을 모두 확인하는데 필요한 만큼 통합 테스트를 추가로 작성하라
- 어떤 예외 상황에 잘못 실행돼 전체 애플리케이션이 즉시 실패하면 해당 예외 상황은 충분한 가치를 가져다 주지 않아서 테스트할 필요가 없다. → 단위 테스트가 적절하다.
{% raw %}
```java
public string changeEmail(int userId, string newEmail){

	User user = UserFactory.create(userId);
	
	string error = user.canChangeEmail(); 
	if(error != null) return error; // ------> 예외 상황


	// method의 나머지 부분
}
```
{% endraw %}

- 빠른 실패 원칙 : 예기치 않은 오류가 발생하자마자 현재 연산을 중단하는 것

## 외부 의존성을 직접 테스트하는 기준


> 📌 프로세스 외부 의존성을 사용하거나 해당 의존성을 목으로 대체하는 두 가지 방법이 있다.  
> **관리 의존성은 실제 인스턴스를 사용하고, 비 관리 의존성은 목으로 대체하라.**


	**관리 의존성은 실제 인스턴스를 사용하고, 비 관리 의존성은 목으로 대체하라.**


![3](/assets/img/2023-10-04-8장-통합-테스트를-하는-이유.md/3.png)


### 관리 의존성

- 애플리케이션을 통해서만 접근할 수 있으며, 해당 의존성과의 상호 작용은 외부 환경에서 볼 수 없다.
- ex. DB : DB에 직접 접근하지 않고 애플리테이션에서 제공하는 API를 통해 접근한다.
- 구현 세부사항이다.

### 비관리 의존성

- 해당 의존성과의 상호 작용을 외부에서 볼 수 있다.
- 사이드 이펙트를 발생 시킬 수 있다.
- ex. SMTP 서버, 메세지 버스
- 비관리 의존성에 대한 통신 패턴을 유지해야하는 것은 하위 호환성을 지켜야 하기 때문이다. → 목이 제격
- 시스템의 식별할 수 있는 동작

### 관리 의존성이면서 비관리 의존성일 때

- 모든 속성을 나타내는 프로세스 외부 의존성이 있다.
- ex. 다른 애플리케이션이 접근할 수 있는 DB
- 다른 애플리케이션에서 볼 수 있는 테이블을 비관리 의존성으로 취급하라. (목으로 대체)
- 나머지 데이터베이스는 관리 의존성으로 취급하고, 상호 작용이 아닌 최종 상태를 검증하라

![4](/assets/img/2023-10-04-8장-통합-테스트를-하는-이유.md/4.png)


### 통합 테스트에서 실제 DB를 사용할 수 없을 때

- 관리 의존성을 목으로 대체하면 통합 테스트의 리팩터링 내성이 저하된다.
- DB가 프로젝트의 유일한 프로세스 외부 의존성이면, 통합 테스트는 회귀 방지에 있어 기존 단위 테스트 세트와 다를바 없다.
- DB를 그대로 테스트할 수 없으면 통합 테스트를 아예 작성하지 말고 도메인 모델의 단위 테스트에만 집중하라.

## 통합 테스트 예제


![5](/assets/img/2023-10-04-8장-통합-테스트를-하는-이유.md/5.png)

- 테스트 할 시나리오 선정
	- 가장 긴 주요 흐름은 모든 프로세스 외부 의존성을 거치는 것이다.
	- CRM 프로젝트 (예시 코드)에서 가장 긴 주요 흐름 : 기업 이메일에서 일반 이메일로 변경하는 로직
- DB와 메시지 버스 분류
	- 프로세스 외부 의존성을 두 가지로 분류해서 직접 테스트할 대상과 목으로 대체할 대상을 결정해야 한다.
	- DB에 사용자와 회사를 삽입 → 이메일 변경 시나리오를 실행 → DB 상태 검증
	- 메세지 버스는 비관리 의존성으로 목으로 대체
- E2E 테스트
	- E2E 테스트는 외부 클라이언트를 모방하므로, 테스트 범위에 포함된 모든 프로세스 외부 의존성을 참조하는 배포된 버전의 애플리케이션을 테스트한다.
	- 관리 의존성을 직접 확인해서는 안 되고, 애플리케이션을 통해 간접적으로 확인해야한다.

	![6](/assets/img/2023-10-04-8장-통합-테스트를-하는-이유.md/6.png)

- 예시 코드
	- createUser, createCompany 헬퍼 메서드를 작성해서, 여러 통합 테스트에서 재사용할 수 있다.
	- 입력 매개변수로 사용한 데이터와 별개로 DB 상태를 확인하는 것이 중요하다.
	- 헬퍼 메서드를 사용하면 검증 구절도 크기를 줄일 수 있다.

### 의존성 추상화를 위한 인터페이스 사용

- 프로세스 외부 의존성을 위해 개발자들이 인터페이스를 도입한다.
- 인터페이스를 사용하는 이유
	- 추상화로 느슨한 결합/OCP 를 지킨다 → 단일 구현에서는 오해다.
	- 목을 사용하기 위해 → 비관리 의존성만 목으로 처리하고, 관리 의존성을 컨트롤러에 명시적으로 주입해라

### 통합 테스트 모범 사례

- 통합 테스트를 최대한 활용하는데 도움되는 일반적인 지침
	- 도메인 모델 경계 명시하기
		- 항상 도메인 모델을 코드베이스에서 명시적이고 잘 알려진 위치에 둬라.
	- 애플리케이션 내 계층 줄이기
		- 애플리케이션에 추상 계층이 너무 많으면 코드 베이스를 탐색하기 어렵고 아주 간단한 연산이라 해도 숨은 로직을 이해하기가 어려워진다.
		- 추상화가 지나치게 많으면 단위 테스트와 통합 테스트에도 도움이 되지 않는다.
		- 가능한 한 간접 계층을 적게 사용하라.
	- 순환 의존성 제거하기
		- 순환 의존성은 코드를 읽고 이해하려고 할 때 알아야 할 것이 많아서 큰 부담이 된다.
		- 테스트를 방해한다.
	- 테스트에서 다중 실행 구절 사용
		- 테스트에서 두개 이상의 준비, 실행, 검증 구절을 두는 것은 코드 악취에 해당한다.
		- 각 실행을 고유의 테스트로 추출해 테스트를 나누는 것이 좋다.

### logging 기능을 테스트 하는 방법

- 로깅을 테스트해야하는가?
	- 애플리케이션의 클라이언트 또는 개발자 이외의 다른 사람이 보는 경우, 로깅은 식별할 수 있는 동작이므로 테스트해야한다. → **`지원 로깅`**
	- 보는이가 개발자뿐이라면, 아무도 모르게 자유로이 수정할 수 있는 구현 세부사항이므로 테스트해서는 안된다. → **`진단 로깅`**
- 어떻게 테스트해야하는가?
	- 지원 로깅은 비지니스 요구 사항이므로, 코드에 명시적으로 반영하라
	- 명시적으로 나열하는 특별한 logger class를 만들고 해당 클래스와의 상호 작용을 확인하라 (구조화된 로깅 개념과 유사)
	- 구조화된 로깅 : 로그 데이터 캡처와 렌더링을 분리하는 로깅 기술. 평범한 로그 파일이나 JSON, CSV 파일 같이 여러 렌더링을 설정할 수 있다.

		![7](/assets/img/2023-10-04-8장-통합-테스트를-하는-이유.md/7.png)

- 로깅이 얼마나 많으면 충분한가?
	- 진단 로깅을 과도하게 사용하지 않는 것이 중요하다.
	- 과도한 로깅은 코드를 혼란스럽게 한다.
	- 로그가 많을 수록 관련 정보를 찾기 어려워진다.
- 로거 인스턴스를 어떻게 전달하는가?
	- 정적 메서드를 사용
		- 의존성이 숨어있고 변경이 어렵다, 테스트가 어려워진다 → 안티패턴이라고 주장하는 사람이 있다.
	- 로거를 명시적으로 주입하는 방법
		- 메서드 인수로 주입
		- 클래스 생성자 사용
