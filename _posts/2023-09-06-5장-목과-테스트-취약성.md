---
date: 2023-09-06
title: "5장 목과 테스트 취약성"
tags: [목, 스텁, 구현세부사항, 캡슐화, hexagonal, ]
categories:
  - Unit Test
excerpt: 목,스텁,구현세부사항,캡슐화,hexagonal

permalink: /unit-test/5장-목과-테스트-취약성/

toc: true
toc_sticky: true
---


## 목과 스텁 구분


### 테스트 대역 유형

- 테스트 대역은 모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적인 용어다.
- 테스트 대역에는 더미, 스텁, 스파이, 목, 페이크 다섯가지가 있다.
- 실제로는 목과 스텁 두가지로 나눌 수 있다.

![0](/assets/img/2023-09-06-5장-목과-테스트-취약성.md/0.png)


### 목

- **외부로 나가는** 상호 작용을 모방하고 검사하는데 도움이 된다.
- 상호작용은 SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당된다.
- ex. 이메일 발송은 외부로 나가는 상호작용이다.

### 스텁

- **내부로 들어오는** 상호작용을 모방하는데 도움된다.
- SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당된다.
- ex. DB에서 데이터를 검색하는 것
- 스텁과의 상호작용을 검증하지 말라.
{% raw %}
	```groovy
	class extends Specification {
	
		def test(){
			given:
			def stub = Mock(Api.class) // stub
			stub.getNumberOfUsers() >> 10
			def sut = new Controller(stub);
			
			when:
			def result = sut.createReport();
	
			then:
			result.numberOfUsers == 10
			1 * stub.getNumberOfUsers() // stub과의 상호작용을 검증하는 부분 -> 잘못됨
		}	
	
	}
	```
{% endraw %}


### 도구로서의 목

- 목은 테스트 대역을 말하기도 하지만, **mocking library**의 클래스도 목으로 참고할 수 있다.
- 도구로서의 목을 사용해 목과 스텁, 이 두가지 유형의 테스트 대역을 생성할 수 있기 때문에 **도구로서의 목과 테스트 대역으로서의 목을 혼동하지 말아야한다.**

### 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?


![1](/assets/img/2023-09-06-5장-목과-테스트-취약성.md/1.png)

- 목과 스텁의 개념은 명령 조회 분리 (CQS) 원칙과 관련이 있다.
- 명령은 사이드 이펙트를 일으키고 어떤 값도 반환하지 않는 메서드다. → 목
- 조회는 사이드 이펙트가 없고 값을 반환한다. → 조회
- 항상 CQS 원칙을 따를 수 있는 것은 아니다. ex) stack.pop()

## 식별할 수 있는 동작과 구현 세부 사항


### 식별할 수 있는 동작은 공개 API와 다르다.

- 모든 제품 코드는 2차원으로 분류할 수 있다.
	- 공개 API or 비공개 API
	- 식별할 수 있는 동작 또는 구현 세부 사항
- 식별할 수 있는 동작과 내부 구현 세부 사항에는 미묘한 차이가 있다.
- 코드가 시스템의 식별할 수 있는 동작이려면 다음 중 하나를 해야 한다.
	- 클라이언트가 목표를 달성하는데 도움이 되는 `연산`을 노출하라.
		- 연산 : 계산을 수행하거나 사이드 이펙트를 초래하는 메서드
	- 클라이언트가 목표를 달성하는데 도움이 되는 `상태`을 노출하라.
		- 상태 : 시스템의 현재 상태
- 구현 세부 사항은 연산, 상태 노출 모두 하지 않는다.
- 이상적으로는 시스템의 공개 API는 식별할 수 있는 동작과 일치해야 하며, 모든 구현 세부 사항은 클라이언트 눈에 보이지 않아야 한다.
- 클래스가 구현 세부 사항을 유출하는지 판단하는 데 유용한 규칙
	- 단일한 목표를 달성하고자 클래스에서 **호출해야 하는 연산의 수가 1보다 크면** 해당 클래스에서 구현 세부 사항을 유출할 가능성이 있다.
	- 이상적으로는 단일 연산으로 개별 목표를 달성해야한다.

### 잘 설계된 API와 캡슐화

- 잘 설계된 API를 유지 보수 하는 것은 캡슐화 개념과 관련이 있다.
- 공개 API가 식별할 수 있는 동작 이상으로 커지면 코드는 구현 세부 사항을 유출한다.
- 캡슐화는 코드를 불변성 위반으로부터 보호하는 행위다.
- 구현 세부 사항을 노출하면 캡슐화가 위반되는 경우가 종종 있다.
- 잘 설계된 API의 정의에서 비롯된 다른 지침으로, 연산과 상태를 최소한으로 노출해야한다.

## 목과 테스트 취약성 간의 관계


### Hexagonal Architecture


![2](/assets/img/2023-09-06-5장-목과-테스트-취약성.md/2.png)

- 레이어 간의 원하지 않는 종속성이나 비즈니스 로직으로 인한 사용자 인터페이스 코드의 오염과 같은 객체 지향 소프트웨어 설계의 알려진 구조적 함정을 피하기 위해 Alistair Cockburn에 의해 발명
- 중요한 지침
	- 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리
	- 애플리케이션 내부 통신
		- 서비스 계층에서 도메인 계층으로 흐르는 단방향 의존성 흐름을 규정한다.
		- 도메인 계층은 외부 환경에서 완전히 격리돼야 한다.
	- 애플리케이션 간의 통신
		- 육각형의 각 면은 애플리케이션 내외부 연결을 나타낸다.
- 각 계층의 API를 잘 설계하면 테스트도 프랙탈 구조를 갖기 시작한다.
	- 프랙탈 : 일부 작은 조각이 전체와 비슷한 기하학적 형태
	- 서로 다른 계층의 테스트는 동일한 동작을 서로 다른 수준으로 검증하는 프랙탈 특성이 있다.

	![3](/assets/img/2023-09-06-5장-목과-테스트-취약성.md/3.png)


### 시스템 내부 통신과 시스템 간 통신


![4](/assets/img/2023-09-06-5장-목과-테스트-취약성.md/4.png)

- 시스템 내부 통신
	- 연산을 수행하기 위한 도메인 클래스 간의 협력은 식별할 수 있는 동작이 아니므로 구현 세부 사항에 해당
	- 클라이언트의 목효와 직접적인 관계가 없다.
	- 이런 협력과 결합하면 테스트가 취약해진다.
	- 목을 사용하면 테스트가 구현 세부 사항과 결합하여 리팩터링 내성 지표가 미흡해진다.
- 시스템 간 통신
	- 항상 외부 애플리케이션이 이해할 수 있도록 통신 패턴을 유지해야한다.
	- 목을 사용하면 시스템과 외부 애플리케이션 간의 통신 패턴을 확인할 때 좋다.

### 단위 테스트의 고전파와 런던파 재고

- 런던파를 따라 목을 무분별하게 사용하면 구현 세부 사항에 결합돼 테스트에 리팩터링 내성이 없게 된다.
- 고전파는 테스트 간에 공유하는 의존성만 교체하므로 리팩터링 내성에 훨씬 유리하다.
- 모든 프로세스 외부 의존성을 목으로 해야하는 것은 아니다.
	- 클라이언트가 직접 접근할 수 없으면 구현 세부사항이 된다.
	- ex. 데이터베이스는 애플리케이션과 하나의 시스템으로 취급해야한다.
- 따라서 시스템 간 통신과 해당 통신의 사이드 이펙트가 외부 환경에서만 보일 때만 목을 사용하는 것이 타당하다.
